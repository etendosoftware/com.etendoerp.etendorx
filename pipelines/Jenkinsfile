pipeline {
    options {
        disableConcurrentBuilds()
    }

    environment { // MARK: - Environment Variables
        CONTEXT_NAME        = 'etendo'
        BBDD_SID            = 'etendo'
        BBDD_PORT           = '5432'
        BBDD_SYSTEMUSER     = 'postgres'
        BBDD_SYSTEMPASS     = 'syspass'
        BBDD_USER           = 'tad'
        BBDD_PASSWORD       = 'tad'
        NEXUS_USER          = credentials('nexus-admin-user')
        NEXUS_PASSWORD      = credentials('nexus-admin-passwd')
        GITHUB_USER         = 'etendobot'
        GITHUB_TOKEN        = credentials('github-read-package-token')

        ACCESS_TOKEN        = credentials('access_token_github')

        REPOSITORY_NAME     = 'com.etendoerp.etendorx'

        EMAIL_ADDRESS       = credentials('email_builds')

        CORE_URL_REPO           = 'https://github.com/etendosoftware/etendo_core'
        RX_URL_REPO             = 'https://github.com/etendosoftware/etendo_rx'
        URL_REPO                = 'https://github.com/etendosoftware/com.etendoerp.etendorx'
        RX_MODULE_SSH           = 'git@github.com:etendosoftware/com.etendoerp.etendorx.git'
        BRANCH_NAME_RX          = 'develop'
        RX_DIR                  = 'etendo_rx'
        CLASSIC_DIR             = 'etendo_core'

        COMMIT_AUTHOR_NAME  = sh(returnStdout: true, script: "git log -1 --pretty=format:'%an'").trim()
        COMMIT_AUTHOR_EMAIL = sh(returnStdout: true, script: "git log -1 --pretty=format:'%ae'").trim()

        JAVA_HOME           = '/usr/lib/jvm/java-17-openjdk-amd64'
        BUILD_CLASSIC       = true

        CONTEXT_BUILD       = 'Module Tests'
        STATUSCORE          = '1'

        COMMIT_INPROGRESS_STATUS = "pending"
        COMMIT_SUCCESS_STATUS    = "success"
        COMMIT_FAILED_STATUS     = "failure"

        SUCCESS             = 'SUCCESS'
        FAILED              = 'FAILED'
        UNSTABLE            = 'UNSTABLE'

        SONAR_SERVER        = "https://sonar.etendo.cloud"
        SONAR_TOKEN         = credentials('sonar-token-access')

        TRUE                = 'true'
        FALSE               = 'false'

        MAIN_BRANCH    = "main"
        DEVELOP_BRANCH = "develop"

        JIRA_ACCESS_TOKEN = credentials('jira-access-token') // Jenkins credential stored as base64-encoded string for another Atlassian user, not etendobot
        JIRA_BASE_URL       = credentials('jira-url')
        EXTRA_MODULES_FILE = "jenkinsExtraModules.txt"
    }

    agent { // MARK: - Agent
        kubernetes {
            inheritFrom 'jenkins-node-rx'
            defaultContainer 'jnlp'
            yamlFile 'pipelines/Agent.yaml'
        }
    }
    stages { // MARK: - Stages
        stage ('RX Setup') { // MARK: - RX Setup
            steps {
                container('compiler') {
                    script {
                        try {
                            env.WORKDIR_MODULE = "${CLASSIC_DIR}/modules/${REPOSITORY_NAME}"
                            echo '---------------------- Clonning RX Repo ----------------------'
                            sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"RX Setup\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""

                            echo '---------------------- Setup RX Repo ----------------------'
                            sh """
                            git clone ${RX_URL_REPO}
                            cd ${RX_DIR}
                            cp gradle.properties.template gradle.properties
                            sed -i 's/^githubUser=.*/githubUser=${GITHUB_USER}/' gradle.properties
                            sed -i 's/^githubToken=.*/githubToken=${GITHUB_TOKEN}/' gradle.properties
                            sed -i 's/^grpc.enabled=.*/grpc.enabled=true/' gradle.properties
                            sed -i 's/^data-rest.enabled=.*/data-rest.enabled=true/' gradle.properties
                            echo "\nrx.checkModuleVersion=false" >> gradle.properties
                            ./gradlew :setup
                            """
                            echo '---------------------- Setting up Environment Variables ----------------------'
                            env.JACOCO_REPORT_EXISTS = FALSE // Initialize Jacoco report existence flag
                            env.TEST_STATUS = SUCCESS // Initialize test status
                            env.RX_STATUS = SUCCESS // Initialize RX build status
                            env.CODE_SCHEMA_VERIFICATION = SUCCESS // Initialize code and schema verification status
                            env.VERIFICATIONS_MESSAGE = '' // Initialize verifications message
                            env.CORE_BRANCH = env.MAIN_BRANCH // Default to main branch
                            env.FROM_BACKPORT = FALSE // Initialize backport flag
                            env.FAILED_SUITES = "" // List to collect failed test suites

                            echo '---------------------- Clone and Setup RX Repo Successful ----------------------'
                            currentBuild.result = SUCCESS
                        } catch (Exception e) {
                            echo '---------------------- Clone and Setup RX Repo Failed ----------------------'
                            echo 'Exception occurred: ' + e.toString()
                            currentBuild.result = FAILED
                            error('Clone and Setup RX Repo Failed')
                            env.RX_STATUS = FAILED
                        }
                    }
                }
            }
        }
        stage ('Build Environment Etendo Core') { // MARK: - Build Environment Etendo Core
            when {
                expression {
                    env.BUILD_CLASSIC == TRUE && currentBuild.result == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        try {
                            sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Build Environment Etendo Classic\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                            withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                                withCredentials([usernamePassword(credentialsId: "koodu_credentials", passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                                    def sshCmd = "ssh -i ${keyfile} -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"                                    

                                    echo '-------------------------- Selecting the Classic Correct Branch for Repository Cloning --------------------------'
                                    def yearBackportBranch = (env.BACKPORT_BRANCH =~ /release\/(\d{2})\./)?.find() ? (env.BACKPORT_BRANCH =~ /release\/(\d{2})\./)[0][1] : null
                                    def yearPrereleaseBranch = (env.PRERELEASE_BRANCH =~ /prerelease\/(\d{2})\./)?.find() ? (env.PRERELEASE_BRANCH =~ /prerelease\/(\d{2})\./)[0][1] : null
                                    if (env.GIT_BRANCH.startsWith(env.DEVELOP_BRANCH) || ((env.GIT_BRANCH.startsWith("feature") || env.GIT_BRANCH.startsWith("epic")) && !(env.GIT_BRANCH.contains("-Y")))) {
                                        env.CORE_BRANCH = env.DEVELOP_BRANCH
                                    } else if (env.GIT_BRANCH.contains("-Y")) {
                                        def yearCommitBranch = (GIT_BRANCH =~ /-Y(\d{2})/)?.find() ? (GIT_BRANCH =~ /-Y(\d{2})/)[0][1] : null
                                        if (yearCommitBranch && yearBackportBranch && yearPrereleaseBranch) {
                                            env.FROM_BACKPORT = (yearCommitBranch == yearBackportBranch) ? TRUE : FALSE
                                            if (env.FROM_BACKPORT == TRUE) {
                                                env.CORE_BRANCH = env.BACKPORT_BRANCH
                                            } else {
                                                env.CORE_BRANCH = env.PRERELEASE_BRANCH
                                            }
                                        } else {
                                            error("Year mismatch between module branch (${yearCommitBranch}), backport branch (${yearBackportBranch}) and prerelease branch (${yearPrereleaseBranch}). Cannot determine correct CORE branch.")
                                        }
                                    }  else if (env.GIT_BRANCH.startsWith("release")) {
                                        echo '-------------------------- Release Branch Detected --------------------------'
                                        env.CORE_BRANCH = env.BACKPORT_BRANCH
                                        echo "Backport Branch: ${env.CORE_BRANCH}"
                                    } else if (env.GIT_BRANCH.startsWith("prerelease")) {
                                        echo '-------------------------- Prerelease Branch Detected --------------------------'
                                        env.CORE_BRANCH = env.PRERELEASE_BRANCH
                                        echo "Prerelease Branch: ${env.CORE_BRANCH}"
                                    }

                                    echo '---------------------- Clonning Classic Repo ----------------------'
                                    sh "git clone --branch ${CORE_BRANCH} ${CORE_URL_REPO}"

                                    echo '---------------------- Environment Variables ----------------------'
                                    sh 'printenv'

                                    echo '---------------------- Clonning RX Module Repo ----------------------'
                                    sh """
                                    cd ${CLASSIC_DIR}
                                    mkdir -p modules
                                    cd modules
                                    GIT_SSH_COMMAND=\"${sshCmd}\" git clone ${RX_MODULE_SSH}
                                    cd ${REPOSITORY_NAME}
                                    git checkout ${GIT_COMMIT}
                                    cd ../..
                                    """
                                    
                                    echo '-------------------------- Cloning of other modules --------------------------'
                                    env.EXTRA_MODULES = ''
                                    env.REPOS_INFO = ''
                                    def currentBranch = ''
                                    if (fileExists("${CLASSIC_DIR}/modules/${REPOSITORY_NAME}/pipelines/${EXTRA_MODULES_FILE}")) {
                                        env.EXTRA_MODULES = readFile("${CLASSIC_DIR}/modules/${REPOSITORY_NAME}/pipelines/${EXTRA_MODULES_FILE}").trim()

                                        def extraModules = []
                                        if (env.EXTRA_MODULES != ''){
                                            extraModules = env.EXTRA_MODULES.tokenize(',')
                                            env.REPOS_INFO = "<em>üß≤ Branches used in dependent modules:</em><br><ul>"
                                        }
                                        def module_package = ''

                                        def isFeatureBranch = env.GIT_BRANCH.startsWith("feature/")
                                        def epicKey = ''
                                        if (isFeatureBranch) {
                                            echo '-------------------------- Feature Branch Detected --------------------------'
                                            def taskName = env.GIT_BRANCH.replaceAll("feature/", "").replaceAll("-Y\\d+", "")
                                            epicKey = sh(script: "bash ${env.WORKDIR_MODULE}/pipelines/utils/jira/jira-utils.sh ${taskName} ${JIRA_BASE_URL} ${JIRA_ACCESS_TOKEN}", returnStdout: true).trim()
                                            if (epicKey) {
                                            echo "Epic Key: ${epicKey}"
                                            if (env.GIT_BRANCH.contains("-Y")) {
                                                env.EPIC_BRANCH = "epic/${epicKey}-Y${env.GIT_BRANCH.split('-Y')[1]}"
                                            } else {
                                                env.EPIC_BRANCH = "epic/${epicKey}"
                                            }
                                            echo "Epic Branch: ${env.EPIC_BRANCH}"
                                            }
                                        }

                                        for (String module in extraModules) {
                                            module_package = sh(script: "echo '${module}' | sed -E 's#.*/##' | sed 's/.git\$//'", returnStdout: true).trim()
                                            echo "------------------------------- Clone ${module_package} Module --------------------------"
                                            sh """
                                            cd ${CLASSIC_DIR}/modules
                                            GIT_SSH_COMMAND='${sshCmd}' git clone ${module}
                                            """

                                            if (!(env.GIT_BRANCH.contains("-Y")) &&  !(env.GIT_BRANCH.startsWith("prerelease")) && !(env.GIT_BRANCH.startsWith("release")) && !(env.GIT_BRANCH.startsWith("main" )) && !(env.GIT_BRANCH.startsWith("master")) && !(env.GIT_BRANCH.startsWith("hotfix"))) {
                                                echo "-------------------------- Checking out to ${module_package} Module Branch --------------------------"
                                                if (isFeatureBranch && epicKey) {
                                                    sh """
                                                    cd ${CLASSIC_DIR}/modules/${module_package}
                                                    git checkout ${env.EPIC_BRANCH} || git checkout ${env.DEVELOP_BRANCH}
                                                    """
                                                } else {
                                                    sh """
                                                    cd ${CLASSIC_DIR}/modules/${module_package}
                                                    git checkout ${env.DEVELOP_BRANCH}
                                                    """
                                                }
                                            } else if (env.FROM_BACKPORT == TRUE || env.GIT_BRANCH.startsWith("release")) {
                                                if (isFeatureBranch && epicKey) {
                                                    sh """
                                                    cd ${CLASSIC_DIR}/modules/${module_package}
                                                    git checkout ${env.EPIC_BRANCH} || git checkout ${env.BACKPORT_BRANCH}
                                                    """
                                                } else {
                                                    sh """
                                                    cd ${CLASSIC_DIR}/modules/${module_package}
                                                    git checkout ${env.BACKPORT_BRANCH}
                                                    """
                                                }
                                            } else if (env.FROM_BACKPORT == FALSE || env.GIT_BRANCH.startsWith("prerelease")) {
                                                if (isFeatureBranch && epicKey) {
                                                    sh """
                                                    cd ${CLASSIC_DIR}/modules/${module_package}
                                                    git checkout ${env.EPIC_BRANCH} || git checkout ${env.PRERELEASE_BRANCH}
                                                    """
                                                } else {
                                                    sh """
                                                    cd ${CLASSIC_DIR}/modules/${module_package}
                                                    git checkout ${env.PRERELEASE_BRANCH}
                                                    """
                                                }
                                            }

                                            sh """
                                            cd ${CLASSIC_DIR}/modules/${module_package}
                                            git checkout ${env.GIT_BRANCH} || echo 'Branch ${env.GIT_BRANCH} not found in ${module_package}'
                                            """
                                            currentBranch = sh(script: "cd ${CLASSIC_DIR}/modules/${module_package} && git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()
                                            env.REPOS_INFO += "<li> Module ${module_package}: ${currentBranch}</li>"
                                        }
                                        if (env.REPOS_INFO != '') {
                                            env.REPOS_INFO += "</ul>"
                                            echo "${env.REPOS_INFO}"
                                        } else {
                                            echo "No extra modules found."
                                        }
                                    } else {
                                        echo "${EXTRA_MODULES_FILE} not found for ${REPOSITORY_NAME}, skipping extra modules checkout."
                                    }

                                    dir(CLASSIC_DIR) {
                                        echo '---------------------- Setup Classic Repo ----------------------'
                                        sh """
                                        echo "\n
                                        context.name=${CONTEXT_NAME}
                                        bbdd.sid=${BBDD_SID}
                                        bbdd.port=${BBDD_PORT}
                                        bbdd.systemUser=${BBDD_SYSTEMUSER}
                                        bbdd.systemPassword=${BBDD_SYSTEMPASS}
                                        bbdd.user=${BBDD_USER}
                                        bbdd.password=${BBDD_PASSWORD}
                                        nexusUser=${NEXUS_USER}
                                        nexusPassword=${NEXUS_PASSWORD}
                                        githubUser=${GITHUB_USER}
                                        githubToken=${GITHUB_TOKEN}
                                        allow.root=true
                                        org.gradle.jvmargs=-Dfile.encoding=UTF-8
                                        org.gradle.daemon=false" > gradle.properties
                                        """
                                        sh './gradlew prepareConfig --info --stacktrace'
                                        sh './gradlew setup --info --stacktrace'
                                        sh './gradlew expandModules --info --stacktrace'

                                        echo '---------------------- Building Classic Environment ----------------------'
                                        sh './gradlew install -PignoreConsistency=true --info --stacktrace'
                                        sh './gradlew update.database -PignoreConsistency=true --info --stacktrace'
                                        sh './gradlew smartbuild -PignoreConsistency=true --info --stacktrace'

                                        echo '---------------------- Classic Environment Successful ----------------------'
                                        currentBuild.result = SUCCESS
                                    }
                                }
                            }
                        } catch (Exception e) {
                            env.ERROR_MESSAGE = "Build of Classic Environment Failed"
                            echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                            echo 'Exception occurred: ' + e.toString()
                            currentBuild.result = FAILED
                            error(env.ERROR_MESSAGE)
                        }
                    }
                }
            }
        }
        stage ('Code and Schema Verification') { // MARK: - Code and Schema Verification
            when {
                expression {
                    currentBuild.result == SUCCESS
                }
            }
            steps {
            container('compiler') {
                    script {
                        try {
                            sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running Code and Schema Verification\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                            def verificationsMessage = '<p><strong>Code and Schema Verification:</strong></p>'
                            if (env.CORE_BRANCH != env.BACKPORT_BRANCH) {
                                echo '-------------------------- Checking for "org.apache.commons.lang" usage --------------------------'
                                def commonsLangUsed = sh(script: "grep -rF --exclude-dir=pipelines --include='*.java' 'org.apache.commons.lang.' ${env.WORKDIR_MODULE} || echo 'false'", returnStdout: true).trim()
                                if (commonsLangUsed != FALSE) {
                                    env.COMMONS_LANG_USED = TRUE
                                    def commonsLangMessage = "'org.apache.commons.lang' is used in the module ${REPOSITORY_NAME}. Should be replaced with 'org.apache.commons.lang3'"
                                    verificationsMessage += "<p><em>üö® ${commonsLangMessage}</em></p>"
                                    echo "-------------------------- ${commonsLangMessage} --------------------------"
                                    env.CODE_SCHEMA_VERIFICATION = FAILED
                                }
                            }
                        
                            echo '-------------------------- Checking for duplicate constraints --------------------------'
                            def sqlDuplicateConstraints = "${pwd()}/pipelines/utils/sql/check_duplicate_constraints.sql"
                            def constraintDuplicates = sh(
                                script: """
                                psql -h localhost -U ${BBDD_SYSTEMUSER} -d ${BBDD_SID} -t -A -F '|' -f ${sqlDuplicateConstraints} | cut -d '|' -f1
                                """, returnStdout: true
                            ).trim()

                            if (constraintDuplicates) {
                                echo "Duplicate Constraints Found: ${constraintDuplicates}"
                                verificationsMessage += "<p><em>üö® Duplicate constraints detected in the DB:</em><br><pre>${constraintDuplicates}</pre></p>"
                                env.CODE_SCHEMA_VERIFICATION = FAILED
                            }

                            echo '-------------------------- Checking for orphaned triggers --------------------------'
                            def sqlOrphanedTriggers = "${pwd()}/pipelines/utils/sql/check_orphaned_triggers.sql"
                            def orphanedTriggers = sh(
                                script: """
                                psql -h localhost -U ${BBDD_SYSTEMUSER} -d ${BBDD_SID} -t -A -F '|' -f ${sqlOrphanedTriggers} | cut -d '|' -f1
                                """, returnStdout: true
                            ).trim()

                            if (orphanedTriggers) {
                                echo "Orphaned Triggers Found: ${orphanedTriggers}"
                                verificationsMessage += "<p><em>üö® Orphaned triggers detected in the DB:</em><br><pre>${orphanedTriggers}</pre></p>"
                                env.CODE_SCHEMA_VERIFICATION = FAILED
                            }

                            if (env.CODE_SCHEMA_VERIFICATION == FAILED) {
                                verificationsMessage += "<p>__________________________________________________________</p>"
                                env.VERIFICATIONS_MESSAGE = verificationsMessage
                                echo "${env.VERIFICATIONS_MESSAGE}"
                                env.ERROR_MESSAGE = "Code and Schema Verification Failed"
                                error(env.ERROR_MESSAGE)
                            }
                            echo '-------------------------- Code and Schema Verification SUCCESS --------------------------'
                            currentBuild.result = SUCCESS
                        } catch (Exception e) {
                            env.ERROR_MESSAGE = "Code and schema verification Failed"
                            echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
                            echo "Exception occurred: " + e.toString()
                            currentBuild.result = UNSTABLE
                            error(env.ERROR_MESSAGE)
                        }
                    }
                }
            }
        }
        stage ('Build Environment Etendo RX') { // MARK: - Build Environment Etendo RX
            when {
                expression {
                    currentBuild.result == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        try {
                            sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Build Environment Etendo RX\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                            echo '---------------------- Building Etendo RX Environment ----------------------'
                            echo '---------------------- Checking Branch Type ----------------------'
                            env.IS_HOTFIX_OR_MAIN_BRANCH = FALSE
                            if ((GIT_BRANCH.startsWith('hotfix/') && !(GIT_BRANCH.contains("-Y"))) || GIT_BRANCH.startsWith('main') || GIT_BRANCH.startsWith('master')) {
                                echo "Branch ${GIT_BRANCH} is a hotfix or main/master."
                                env.IS_HOTFIX_OR_MAIN_BRANCH = TRUE
                            }
                            if (IS_HOTFIX_OR_MAIN_BRANCH == FALSE) {
                                echo '---------------------- Checking out to RX Core Branch ----------------------'
                                sh """
                                    cd ${RX_DIR}
                                    git checkout develop
                                """
                            }
                            echo "---------------------- Attempting to checkout to ${GIT_BRANCH} branch in RX Core ----------------------"
                            sh """
                              cd ${RX_DIR}
                              git checkout ${GIT_BRANCH} || echo 'Branch ${GIT_BRANCH} not found in RX Core'
                            """
                            sh """
                            cd ${RX_DIR}
                            ./gradlew generate.entities --info
                            """
                            echo '---------------------- Build of Etendo RX Successful ----------------------'
                            currentBuild.result = SUCCESS
                        } catch (Exception e) {
                            env.ERROR_MESSAGE = "Build of Etendo RX Failed"
                            echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                            echo 'Exception occurred: ' + e.toString()
                            currentBuild.result = FAILED
                            error(env.ERROR_MESSAGE)
                            env.RX_STATUS = FAILED
                        }
                    }
                }
            }
        }
        stage ("Run Etendo RX Module tests") { // MARK: - Run Etendo RX Module tests
            when {
                expression {
                    currentBuild.result == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        def suiteName = "RX Module Tests"
                        try {
                            sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running Module Tests\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""

                            echo '---------------------- Running Etendo RX Module Tests ----------------------'
                            sh """
                            cd ${CLASSIC_DIR}
                            ./gradlew test --tests "com.etendoerp.etendorx.*" --info
                            ./gradlew jacocoRootReport --info
                            """

                            if (fileExists("${CLASSIC_DIR}/build/reports/jacoco/jacocoRootReport/jacocoRootReport.xml")) {
                                echo '----> Jacoco report found'
                                env.JACOCO_REPORT_EXISTS = TRUE
                            } else {
                                echo '----> Jacoco report not found'
                            }
                            echo '---------------------- RX Module Tests Successful ----------------------'
                        } catch (Exception e) {
                            env.ERROR_MESSAGE = "RX Module Tests Failed"
                            echo "---------------------- ${env.ERROR_MESSAGE} ----------------------"
                            echo 'Exception occurred: ' + e.toString()
                            currentBuild.result = UNSTABLE
                            unstable(env.ERROR_MESSAGE)
                            env.TEST_STATUS = UNSTABLE
                            def currentFailed = env.FAILED_SUITES ?: ""
                            env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
                        }
                        publishHTML([
                            allowMissing: false,
                            alwaysLinkToLastBuild: false,
                            keepAll: true,
                            reportDir: "${CLASSIC_DIR}/build/reports/tests/test",
                            reportFiles: '*.html',
                            reportName: 'ETENDO RX MODULE TESTS REPORT',
                            reportTitles: ''
                        ])
                    }
                }
            }
        }
        stage('SonarQube Analysis') { // MARK: - SonarQube Analysis
            when {
                expression {
                    currentBuild.result == SUCCESS && env.JACOCO_REPORT_EXISTS == TRUE
                }
            }
            steps {
                container('compiler') {
                    script {
                        try {
                            sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running SonarQube Analysis\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                            echo '-------------------------- Installing SonarQube Scanner --------------------------'
                            sh """
                                apt-get update && apt-get install -y wget unzip
                                wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-${SONAR_VERSION}-linux.zip
                                unzip sonar-scanner-cli-${SONAR_VERSION}-linux.zip
                                export PATH=\$PATH:\${WORKSPACE}/sonar-scanner-${SONAR_VERSION}-linux/bin
                            """
                            echo '-------------------------- Reading SonarQube Project Key from sonar-project.properties --------------------------'
                            def sonarPropertiesFile = "${CLASSIC_DIR}/modules/${REPOSITORY_NAME}/sonar-project.properties"
                            if (!fileExists(sonarPropertiesFile)) {
                                error("SonarQube properties file not found in ${sonarPropertiesFile}")
                            }
                            def sonarProjectKey = sh(script: "grep 'sonar.projectKey' ${sonarPropertiesFile} | cut -d '=' -f2", returnStdout: true).trim()
                            env.PROJECT_KEY = sonarProjectKey
                            echo "SonarQube Project Key: ${env.PROJECT_KEY}"

                            echo '-------------------------- Checking if module contains Java source files --------------------------'
                            def parsedRepositoryName = REPOSITORY_NAME.replace('.', '/')
                            def sonarSources = '.'
                            if (fileExists("${CLASSIC_DIR}/modules/${REPOSITORY_NAME}/src/${parsedRepositoryName}")) {
                                echo '----> Java source files found in module'
                                sonarSources = "src/${parsedRepositoryName}"
                                echo "SonarQube Sources: ${sonarSources}"
                            }

                            env.WORKDIR_JACOCO = "${pwd()}/${CLASSIC_DIR}/build/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
                            def jacocoReportPathAttribute = "-Dsonar.java.coveragePlugin=jacoco -Dsonar.coverage.jacoco.xmlReportPaths=${env.WORKDIR_JACOCO}"
                            echo "Jacoco Report Path: ${env.WORKDIR_JACOCO}"

                            echo '-------------------------- Executing SonarQube Analysis --------------------------'
                            sh """
                                cd ${CLASSIC_DIR}/modules/${REPOSITORY_NAME}
                                ${WORKSPACE}/sonar-scanner-${SONAR_VERSION}-linux/bin/sonar-scanner -X \
                                    -Dsonar.projectKey=${sonarProjectKey} \
                                    -Dsonar.sources=${sonarSources} \
                                    -Dsonar.host.url=${SONAR_SERVER} \
                                    -Dsonar.login=${SONAR_TOKEN} \
                                    -Dsonar.branch.name=${GIT_BRANCH} \
                                    -Dsonar.projectVersion=${GIT_COMMIT} \
                                    -Dsonar.scm.revision=${GIT_COMMIT} \
                                    ${jacocoReportPathAttribute}
                            """
                            echo '---------------------- Getting SonarQube Report URL ----------------------'
                            def branchName = URLEncoder.encode(GIT_BRANCH, 'UTF-8')
                            def projectUrl = "${SONAR_SERVER}/dashboard?id=${env.PROJECT_KEY}&branch=${branchName}"
                            env.PROJECT_URL = "${projectUrl}"
                            echo "Sonar Project URL: ${PROJECT_URL}"
                            echo '-------------------------- SonarQube Analysis Completed --------------------------'
                        } catch (Exception e) {
                            env.ERROR_MESSAGE = "SonarQube Analysis Failed"
                            echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                            echo 'Exception occurred: ' + e.toString()
                            currentBuild.result = FAILED
                            error(env.ERROR_MESSAGE)
                        }
                    }
                }
            }
        }
        stage('Compare Coverage Results') { // MARK: - Compare Coverage Results
            when {
                expression {
                    currentBuild.result == SUCCESS && env.JACOCO_REPORT_EXISTS == TRUE && !(env.GIT_BRANCH == env.MAIN_BRANCH || env.GIT_BRANCH.startsWith("release/"))
                }
            }
            steps {
                script {
                    try {
                        sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Comparing Coverage Results\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                        echo "SonarQube Project Key: ${env.PROJECT_KEY}"
                        def branchCurrent = URLEncoder.encode(GIT_BRANCH, 'UTF-8') 
                        echo "Sonar Project URL: ${PROJECT_URL}"
                        def branchCompare = 'main'
                        env.COMPARE_COVERAGE_STATUS = SUCCESS
                        if (env.FROM_BACKPORT == TRUE) {
                            branchCompare = env.BACKPORT_BRANCH
                        }
                        echo "-------------------------- Comparing Coverage with ${branchCompare} Branch --------------------------"

                        def rootDir = pwd()
                        def sonarUtils = load "${rootDir}/pipelines/utils/sonarUtils.groovy"

                        // Only check commit on PR branches
                        def checkCommitCurrent = GIT_BRANCH.startsWith('feature/') || GIT_BRANCH.startsWith('hotfix/') || GIT_BRANCH.startsWith('epic/')
                        echo "Check commit for current branch (${GIT_BRANCH}): ${checkCommitCurrent}"
                        def coverageCurrent = sonarUtils.getCoverageWithRetry(
                            GIT_BRANCH,
                            checkCommitCurrent,
                            env.PROJECT_KEY,
                            SONAR_TOKEN,
                            SONAR_SERVER,
                            GIT_COMMIT
                        )
                        def coverageOriginBranch = sonarUtils.getCoverageWithRetry(
                            branchCompare,
                            false,
                            env.PROJECT_KEY,
                            SONAR_TOKEN,
                            SONAR_SERVER,
                            null
                        )

                        echo "Current branch (${env.GIT_BRANCH}) coverage: ${coverageCurrent}%"
                        echo "${branchCompare} branch coverage: ${coverageOriginBranch}%"
                        if (coverageCurrent < coverageOriginBranch) {
                            env.ERROR_MESSAGE = "Coverage (${coverageCurrent}%) is lower than ${branchCompare} branch (${coverageOriginBranch}%)"
                            echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
                            currentBuild.result = UNSTABLE
                            env.COMPARE_COVERAGE_STATUS = FAILED
                            unstable(env.ERROR_MESSAGE)
                        } else {
                            echo '-------------------------- Coverage is OK --------------------------'
                            currentBuild.result = SUCCESS
                        }
                    } catch (Exception e) {
                        echo "Exception occurred: " + e.toString()
                        env.ERROR_MESSAGE = "Comparing Coverage Results Failed"
                        echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
                        currentBuild.result = UNSTABLE
                        error(env.ERROR_MESSAGE)
                    }
                }
            }
        }
        stage ("Run Das Tests") { // MARK: - Run Das Tests
            when {
                expression {
                    env.RX_STATUS == SUCCESS && env.CODE_SCHEMA_VERIFICATION == SUCCESS
                }
            }
            steps {
                container("compiler") {
                    script {
                        def suiteName = "Das Tests"
                        try {
                            sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running Das Tests\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                            echo '---------------------- Running Das Tests ----------------------'
                            def tests = [
                                "com.etendorx.das.test.RepositoryTest",
                                "com.etendorx.das.test.RestCallTest",
                                "com.etendorx.das.test.DefaultFiltersTest",
                                "com.etendorx.das.test.eventhandlertest.test.AnnotationTests",
                                "com.etendorx.das.unit.BindedRestControllerTest",
                                "com.etendorx.das.unit.JsonPathEntityRetrieverDefaultTest",
                                "com.etendorx.das.unit.MappingUtilsImplTest",
                                "com.etendorx.das.test.DisableEnableTriggersTest",
                                "com.etendorx.das.test.FieldMappingRestCallTest",
                                "com.etendorx.das.integration.PropertyMetadataTest",
                                "com.etendorx.das.unit.BaseDTORepositoryDefaultTests",
                                "com.etendorx.das.unit.JsonPathConverterBaseTests",
                                "com.etendorx.entities.mapper.lib.JsonPathEntityRetrieverBaseTests"
                            ]
                            dir(RX_DIR) {
                                tests.each { test ->
                                    sh "./gradlew :com.etendorx.das:test --info --tests ${test}"
                                }
                            }
                            echo '---------------------- Das Tests Successful ----------------------'
                        } catch (Exception e) {
                            env.ERROR_MESSAGE = "Das Tests Failed"
                            echo "---------------------- ${env.ERROR_MESSAGE} ----------------------"
                            echo 'Exception occurred: ' + e.toString()
                            currentBuild.result = UNSTABLE
                            unstable(env.ERROR_MESSAGE)
                            env.TEST_STATUS = UNSTABLE
                            def currentFailed = env.FAILED_SUITES ?: ""
                            env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
                        }
                        if(fileExists("${RX_DIR}/modules_core/com.etendorx.das/build/reports/tests/test")) {
                            publishHTML([
                                allowMissing: false,
                                alwaysLinkToLastBuild: false,
                                keepAll: true,
                                reportDir: "${RX_DIR}/modules_core/com.etendorx.das/build/reports/tests/test",
                                reportFiles: '*.html',
                                reportName: 'DAS TESTS REPORT',
                                reportTitles: ''
                            ])
                        }
                    }
                }
            }
        }
    }
    post { // MARK: - Post Actions
        failure {
            script {
                env.EMAIL_SUBJECT = 'Build Failed'
                sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_FAILED_STATUS} \"${env.EMAIL_SUBJECT}\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                echo "---------------------- ${env.ERROR_MESSAGE} ----------------------"
            }
            mail to: EMAIL_ADDRESS,
            subject: "‚õî ${env.EMAIL_SUBJECT} - ${currentBuild.fullDisplayName}",
            mimeType: "text/html",
            body:  """
            <html>
                <head>
                    <style>
                        body { font-family: 'Arial', sans-serif; }
                        .header { font-size: 16px; font-weight: bold; color: #FF0000; }
                    </style>
                </head>
                <body>
                    <p><em>${new Date()}</em></p>
                    <p>__________________________________________________________</p>

                    <h2 class="header">üö´ ${env.EMAIL_SUBJECT} üö´</h2>

                    <p><strong>Reasons ‚á¢ <em>${env.ERROR_MESSAGE}</em></strong></p>

                    <p>
                        <strong>‚Ä¢ Commit:</strong> <a href="${URL_REPO}/commits/${env.GIT_COMMIT}">${URL_REPO}/commits/${env.GIT_COMMIT}</a><br />
                        <strong>‚Ä¢ Author:</strong> ${COMMIT_AUTHOR_NAME} (${COMMIT_AUTHOR_EMAIL})
                    </p>

                    ${env.REPOS_INFO}

                    <p>
                        The build has failed unexpectedly.<br />
                        üí° This build was on an Full Etendo (CORE and RX) build environment based on RX module commit.<br />
                        To more information on the failing run visit:<br />
                        <a href="${env.BUILD_URL}">${env.BUILD_URL}</a>
                    </p>
            __________________________________________________________
            """
        }
        unstable {
            script {
                sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_FAILED_STATUS} \"${env.ERROR_MESSAGE}\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                echo "---------------------- ${env.ERROR_MESSAGE} ----------------------"
                
                def mailSubject = ""
                def moreInfo = ""
                def bodyMessageError = ""

                if (env.CODE_SCHEMA_VERIFICATION == FAILED) {
                    mailSubject = "Failed Code and Schema Verification"
                    bodyMessageError = env.VERIFICATIONS_MESSAGE
                } else if (env.TEST_STATUS == UNSTABLE) {
                    mailSubject = "Failed Tests"
                    if (env.FAILED_SUITES && !env.FAILED_SUITES.isEmpty()) {
                        bodyMessageError = "Failed Test Suites: ${env.FAILED_SUITES}"
                    } else {
                        bodyMessageError = "Failed tests have been detected in the RX module."
                    }
                } else if (env.COMPARE_COVERAGE_STATUS == FAILED) {
                    mailSubject = "Coverage Decreased"
                    bodyMessageError = "<p><strong>${env.ERROR_MESSAGE}</strong></p>"
                    moreInfo = "Check the <a href='${env.PROJECT_URL}'>SonarQube Report</a> for more details about the coverage.<br/>"
                }
                env.EMAIL_SUBJECT = mailSubject
                env.MORE_INFO = moreInfo
                env.BODY_MESSAGE_ERROR = bodyMessageError
            }
            mail to: EMAIL_ADDRESS,
                subject: "‚ö†Ô∏è ${env.EMAIL_SUBJECT} - ${currentBuild.fullDisplayName}",
                mimeType: "text/html",
                body: """
                    <html>
                        <head>
                            <style>
                                body { font-family: 'Arial', sans-serif; }
                                .header { font-size: 16px; font-weight: bold; color: #FFA500; }
                            </style>
                        </head>
                        <body>
                            <p><em>${new Date()}</em></p>
                            <p>__________________________________________________________</p>

                            <h2 class="header">‚ö†Ô∏è ${env.EMAIL_SUBJECT} ‚ö†Ô∏è</h2>

                            <p><strong>Reasons ‚á¢ <em>${env.BODY_MESSAGE_ERROR}</em></strong></p>

                            <p>
                                <strong>‚Ä¢ Commit:</strong> <a href="${URL_REPO}/commits/${env.GIT_COMMIT}">${URL_REPO}/commits/${env.GIT_COMMIT}</a><br />
                                <strong>‚Ä¢ Author:</strong> ${COMMIT_AUTHOR_NAME} (${COMMIT_AUTHOR_EMAIL})
                            </p>

                            ${env.REPOS_INFO}

                            <p>
                                ${env.MORE_INFO}
                                To more information on the failing run, visit <a href='${env.BUILD_URL}'>Jenkins Build</a>
                            </p>
                    __________________________________________________________
                """
        }
        success {
            script {
                sh "./pipelines/utils/build-update.sh ${REPOSITORY_NAME} ${COMMIT_SUCCESS_STATUS} \"Test Finalized Successfully\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                echo '---------------------- DONE ----------------------'
            }
        }
    }
}
