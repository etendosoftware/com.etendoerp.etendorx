def ETENDORX_PRODUCTION_REPOSITORY_URL = "https://maven.pkg.github.com/etendosoftware/com.etendoerp.platform.extensions"
def ETENDORX_SNAPSHOT_REPOSITORY_URL = "https://repo.futit.cloud/repository/etendo-snapshot-jars"
project.ext {
    ETENDORX_VERSION = "2.3.3"
}

// InteractiveSetupManager will be resolved at flush time (if available)

// Map to accumulate interactive setup properties to write later
ext.collectedInteractiveSetupProps = [:]

private void saveInteractiveProp(String key, String value) {
    if (key != null && value != null) {
        ext.collectedInteractiveSetupProps[key] = value
    }
}

private boolean flushInteractiveSetup(Project proj) {
    try {
        def ismClass = Class.forName('com.etendoerp.legacy.interactive.InteractiveSetupManager')
        def writeMethod = ismClass.getMethod('writeResultsForInteractiveSetup', Project.class, Map.class)
        writeMethod.invoke(null, proj, ext.collectedInteractiveSetupProps)
        return true
    } catch (ClassNotFoundException e) {
        proj.logger.debug("InteractiveSetupManager not available: ${e.message}")
        return false
    } catch (Exception e) {
        proj.logger.warn("Failed to write interactive setup results: ${e.message}")
        return false
    }
}

// Console helpers to avoid duplication when prompting the user
private BufferedReader getConsoleReader() {
    return new BufferedReader(new InputStreamReader(System.in))
}

/**
 * Ask a yes/no question. Returns true for yes, false for no.
 * Accepts defaultYes=true to consider empty input as yes.
 */
private boolean askYesNo(BufferedReader reader, String prompt, boolean defaultYes) {
    println prompt
    System.out.flush()
    def answer = reader.readLine()?.trim()
    if (answer == null || answer == '') {
        return defaultYes
    }
    return (answer.equalsIgnoreCase('y') || answer.equalsIgnoreCase('yes'))
}

/**
 * Ask for arbitrary input and return trimmed string (or null if empty).
 */
private String askInput(BufferedReader reader, String prompt) {
    println prompt
    System.out.flush()
    def answer = reader.readLine()?.trim()
    return (answer && answer.length() > 0) ? answer : null
}

def volumesDir = project.providers
        .provider {
            def volumenPath = project.findProperty('VOLUMES_PATH')
            if (volumenPath) {
                return file(volumenPath)
            } else {
                return project.layout.buildDirectory.dir("../volumes").get().getAsFile()
            }
        }

def sourceDir = project.providers
        .provider {
            def red = "\u001B[31;1m"
            def reset = "\u001B[0m"

            Project moduleProject = project.findProject(":modules")
            Project rxProject = null
            if (moduleProject != null) {
                rxProject = moduleProject.findProject("com.etendoerp.etendorx")
            }
            File jarModulesLocation = new File(project.buildDir, "etendo" + File.separator + "modules")
            File rxJarModule = new File(jarModulesLocation, "com.etendoerp.etendorx")
            if (rxProject != null || rxJarModule.exists()) {
                return rxProject != null ? rxProject.projectDir.path : rxJarModule.path
            } else {
                throw new GradleException("${red}‚ùå RX module not found.${reset}")
            }
        }
        .map { file(it) }

def isRXDockerized() {
    getTypedProp('docker_com.etendoerp.etendorx') ?: false
}

def isJaegerDockerized() {
    getTypedProp('docker_com.etendoerp.etendorx_utils') ?: false
}

def isTomcatDockerized() {
    getTypedProp('docker_com.etendoerp.tomcat') ?: false
}

def isEnableOpentelemetryTomcat() {
    getTypedProp('otel.tomcat.enable') ?: false
}

def isConnectorDockerized() {
    getTypedProp('docker_com.etendoerp.etendorx_connector') ?: false
}

def isAsyncProcessDockerized() {
    getTypedProp('docker_com.etendoerp.etendorx_async') ?: false
}

task "rx.setup.files" {
    description = 'Finds all Docker Compose YAML files and copies them to build/compose'
    group = 'Docker'
    doLast {
        if (isRXDockerized()) {
            def destDirCopy = layout.buildDirectory.dir("compose").get().asFile
            def composeDirs = ['dynamic', 'das']
            composeDirs.each { dirName ->
                copy {
                    from fileTree(dir: sourceDir.map { it.toPath().resolve("compose/${dirName}").toFile() })
                    into "${destDirCopy}/${dirName}"
                }
            }
        }
    }
}
task "rx.setup" {
    description = 'Finds all Docker Compose YAML files and copies them to build/compose'
    group = 'Docker'

    doLast {
        if (isRXDockerized()) {
            println("Copying RX config files")
            // Ensure the destination directory exists
            def destDir = layout.buildDirectory.dir("rxconfig").get().asFile
            if (!destDir.exists()) {
                destDir.mkdirs()
            }

            def dirs = ['modules', layout.buildDirectory.dir("etendo/modules").get().asFile]
            dirs.each { dir ->
                // Collect .yaml and .yaml.template files
                def yamlFiles = fileTree(dir: dir, include: '**/rxconfig/*.yaml').collect { it.name }
                def templateFiles = fileTree(dir: dir, include: '**/rxconfig/*.yaml.template')

                templateFiles.each { template ->
                    def yamlName = template.name.replace('.template', '')
                    def destFile = new File(destDir, yamlName)

                    // If the .yaml file doesn't exist, use the template to generate it
                    if (!yamlFiles.contains(yamlName)) {
                        println("Using template for missing file: ${yamlName}")
                        copy {
                            from template
                            into destDir
                            rename { it.replace('.template', '') }
                        }
                    } else {
                        // If the .yaml file exists, copy it directly
                        println("Using existing .yaml file: ${yamlName}")
                        copy {
                            from new File(template.parent, yamlName)
                            into destDir
                        }
                    }
                    def content = destFile.text
                    content = content.replace('{TOMCAT_URL}', isTomcatEnabled ? 'tomcat' : 'host.docker.internal')
                    content = content.replace('{TOMCAT_PORT}', isTomcatEnabled ? '8080' : tomcatPort.toString())
                    content = content.replace('{BBDD_URL}', isBBDDEnabled ? 'db' : 'host.docker.internal')
                    content = content.replace('{BBDD_PORT}', isBBDDEnabled ? '5432' : project.property("bbdd.port").toString())
                    content = content.replace('{BBDD_SID}', project.property("bbdd.sid").toString())
                    content = content.replace('{CONTEXT_NAME}', project.property("context.name").toString())
                    content = content.replace('{ETENDORX_BASEPACKAGE}', project.hasProperty("etendorx.basepackage") ? project.property("etendorx.basepackage").toString() : "")
                    content = content.replace('{OBCON_URL}', isTomcatEnabled ? 'obconnsrv' : 'host.docker.internal')
                    destFile.text = content
                }
            }
            executeDockerComposeCommand("cp ${destDir} config:/")

        }
    }
}

task "rx.env.file" {
    description = 'Generates the .env file for RX'
    group = 'Docker'

    doLast {
        def props = envFile()
        def env = props.envFile
        def properties = props.properties
        def version = "${project.ext.ETENDORX_VERSION}"

        upsertEnvProperty('ETENDORX_VERSION', version)
        def etendorx_repository_url = "${ETENDORX_PRODUCTION_REPOSITORY_URL}"
        def etendorx_repository_user = "${properties.getProperty("githubUser")}"
        def etendorx_repository_password = "${properties.getProperty("githubToken")}"
        if ("${ETENDORX_VERSION}".contains("SNAPSHOT")) {
            etendorx_repository_url = "${ETENDORX_SNAPSHOT_REPOSITORY_URL}"
            etendorx_repository_user = "${properties.getProperty("nexusUser")}"
            etendorx_repository_password = "${properties.getProperty("nexusPassword")}"
        }
        upsertEnvProperty('ETENDORX_REPOSITORY_URL', etendorx_repository_url)
        upsertEnvProperty('ETENDORX_REPOSITORY_USER', etendorx_repository_user)
        upsertEnvProperty('ETENDORX_REPOSITORY_PASSWORD', etendorx_repository_password)

        def destUrl = isBBDDEnabled ? "db" : "host.docker.internal"
        def port = isBBDDEnabled ? "5432" : getTypedProp("bbdd.port")
        def sid = getTypedProp("bbdd.sid") ?: "etendo"
        def contextName = getTypedProp("context.name") ?: "etendo"
        upsertEnvProperty("ETENDORX_DB_HOST", destUrl)
        upsertEnvProperty("ETENDORX_DB_PORT", port)
        upsertEnvProperty("ETENDORX_DB_SID", sid)

        def tomcatHost = "tomcat"
        if (!isTomcatEnabled) {
            tomcatHost = "host.docker.internal"
        }
        def configServerUrl = "http://${tomcatHost}:${tomcatPort}/${contextName}/buildConfig"
        upsertEnvProperty("ETENDORX_CONFIG_SERVER_URL", configServerUrl)

        // Etendo RX Resource Limits
        def rxServiceFactors = [
                CONFIG: [mem: 1.0, cpu: 1.0], // Default 256Mb - 1.0 Cpu
                DAS   : [mem: 8.0, cpu: 1.0], // Default 2048Mb - 1.0 Cpu
                AUTH  : [mem: 1.0, cpu: 1.0], // Default 256Mb - 1.0 Cpu
                EDGE  : [mem: 1.0, cpu: 1.0]  // Default 256Mb - 1.0 Cpu
        ]
        def RX_BASE_MEM_MB = getTypedProp("rx.base.memory.mb")
        if (RX_BASE_MEM_MB != null) {
            rxServiceFactors.each { service, factors ->
                def memMB = (RX_BASE_MEM_MB * factors.mem).toInteger()
                upsertEnvProperty("BASE_${service}_MEMORY_LIMIT", "${memMB}M")
            }
        }
        def RX_BASE_CPU = getTypedProp("rx.base.cpu")
        if (RX_BASE_CPU != null) {
            rxServiceFactors.each { service, factors ->
                def cpu = ((RX_BASE_CPU * factors.cpu) as BigDecimal).setScale(1, BigDecimal.ROUND_HALF_UP).toString()
                upsertEnvProperty("BASE_${service}_CPU_LIMIT", "${cpu}")
            }
        }

        // Connector Resource Limits
        def connectorServiceFactors = [
                OBCONNSRV: [mem: 1.0, cpu: 1.0],  // Default 256Mb - 1.0 Cpu
                WORKER   : [mem: 2.0, cpu: 1.0]   // Default 512Mb - 1.0 Cpu
        ]
        def CONNECTOR_BASE_MEM_MB = getTypedProp("connector.base.memory.mb")
        if (CONNECTOR_BASE_MEM_MB != null) {
            connectorServiceFactors.each { service, factors ->
                def memMB = (CONNECTOR_BASE_MEM_MB * factors.mem).toInteger()
                upsertEnvProperty("BASE_${service}_MEMORY_LIMIT", "${memMB}M")
            }
        }
        def CONNECTOR_BASE_CPU = getTypedProp("connector.base.cpu")
        if (CONNECTOR_BASE_CPU != null) {
            connectorServiceFactors.each { service, factors ->
                def cpu = ((CONNECTOR_BASE_CPU * factors.cpu) as BigDecimal).setScale(1, BigDecimal.ROUND_HALF_UP).toString()
                upsertEnvProperty("BASE_${service}_CPU_LIMIT", "${cpu}")
            }
        }

        // Async Process Resource Limits
        def asyncServiceFactors = [
                KAFKA       : [mem: 4.0, cpu: 1.0],  // Default 1024Mb - 1.0 Cpu
                CONNECT     : [mem: 2.0, cpu: 1.0],  // Default 512Mb  - 1.0 Cpu
                ASYNCPROCESS: [mem: 1.0, cpu: 1.0]   // Default 256Mb  - 1.0 Cpu
        ]
        def ASYNC_BASE_MEM_MB = getTypedProp("async.base.memory.mb")
        if (ASYNC_BASE_MEM_MB != null) {
            asyncServiceFactors.each { service, factors ->
                def memMB = (ASYNC_BASE_MEM_MB * factors.mem).toInteger()
                upsertEnvProperty("BASE_${service}_MEMORY_LIMIT", "${memMB}M")
            }
        }
        def ASYNC_BASE_CPU = getTypedProp("async.base.cpu")
        if (ASYNC_BASE_CPU != null) {
            asyncServiceFactors.each { service, factors ->
                def cpu = ((ASYNC_BASE_CPU * factors.cpu) as BigDecimal).setScale(1, BigDecimal.ROUND_HALF_UP).toString()
                upsertEnvProperty("BASE_${service}_CPU_LIMIT", "${cpu}")
            }
        }

        // Utils Resource Limits
        def utilsServiceFactors = [
                KAFKA_UI     : [mem: 0.5, cpu: 1.0],  // Default 128Mb - 1.0 Cpu
                JAEGER       : [mem: 1.0, cpu: 1.0],  // Default 256Mb - 1.0 Cpu
                JAEGER_HEALTH: [mem: 0.25, cpu: 1.0]   // Default 64Mb  - 1.0 Cpu
        ]
        def UTILS_BASE_MEM_MB = getTypedProp("utils.base.memory.mb")
        if (UTILS_BASE_MEM_MB != null) {
            utilsServiceFactors.each { service, factors ->
                def memMB = (UTILS_BASE_MEM_MB * factors.mem).toInteger()
                upsertEnvProperty("BASE_${service}_MEMORY_LIMIT", "${memMB}M")
            }
        }
        def UTILS_BASE_CPU = getTypedProp("utils.base.cpu")
        if (UTILS_BASE_CPU != null) {
            utilsServiceFactors.each { service, factors ->
                def cpu = ((UTILS_BASE_CPU * factors.cpu) as BigDecimal).setScale(1, BigDecimal.ROUND_HALF_UP).toString()
                upsertEnvProperty("BASE_${service}_CPU_LIMIT", "${cpu}")
            }
        }
    }
}

task "rx.das.restart" {
    dependsOn "rx.setup"
    doLast {
        if (isRXDockerized()) {
            executeDockerComposeCommand("restart das")
        }
    }
}

task "rx.das.stop" {
    doLast {
        if (isRXDockerized()) {
            executeDockerComposeCommand("stop das")
        }
    }
}

task "kafkaConnectSetup" {
    doLast {
        def connectorName = "default"
        def dbUser = getTypedProp('bbdd.systemUser') ?: 'postgres'
        def dbName = getTypedProp('bbdd.sid') ?: 'etendo'
        def dbPass = getTypedProp('bbdd.systemPassword') ?: 'syspass'
        def dbPort = isBBDDEnabled ? '5432' : getTypedProp("bbdd.port") ?: '5432'

        try {
            // Try to load DatabaseConnection reflectively. If the class is not available, skip the DB tests.
            def dbConnClass = null
            try {
                dbConnClass = Class.forName('com.etendoerp.connections.DatabaseConnection')
            } catch (ClassNotFoundException cnfe) {
                project.logger.debug("DatabaseConnection class not available, skipping DB connectivity test: ${cnfe.message}")
            }

            if (dbConnClass != null) {
                def dbConn = dbConnClass.getConstructor(Project.class).newInstance(project)
                if (!dbConn.loadSystemDatabaseConnection()) {
                    throw new IllegalStateException('Could not load database connection using project config (Openbravo.properties).')
                }

                // Use try-with-resources so Connection, Statements, ResultSets and PreparedStatements are closed automatically
                try (java.sql.Connection connection = dbConn.getConnection()) {
                    if (connection == null || connection.isClosed()) {
                        throw new IllegalStateException('Database connection is null or closed.')
                    }
                    println "‚úÖ Database connection test successful."

                    // check wal_level
                    def setWallLevel = false
                    try (def stmt = connection.createStatement();
                         def rs = stmt.executeQuery("SELECT setting FROM pg_settings WHERE name = 'wal_level'")) {
                        if (rs.next()) {
                            def walLevel = rs.getString("setting")
                            if (walLevel != 'logical') {
                                setWallLevel = true
                            } else {
                                println "‚úÖ Database wal_level is set to 'logical'."
                            }
                        } else {
                            throw new IllegalStateException("Could not retrieve wal_level from pg_settings.")
                        }
                    }

                    // Check if table public.etask_task has REPLICA IDENTITY FULL
                    def needSetReplicaLevelTask = false
                    try (def stmt2 = connection.createStatement();
                         def rs2 = stmt2.executeQuery("SELECT relreplident FROM pg_class WHERE relname = 'etask_task' AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')")) {
                        if (rs2.next()) {
                            def replIdent = rs2.getString("relreplident")
                            if (replIdent != 'f') {
                                needSetReplicaLevelTask = true
                            }
                        } else {
                            throw new IllegalStateException("Could not retrieve relreplident for public.etask_task.")
                        }
                    }

                    if (setWallLevel || needSetReplicaLevelTask) {
                        println "‚ö†Ô∏è Database configuration changes are required for Kafka Connect to function properly."
                    } else {
                        println "‚úÖ Database configuration is suitable for Kafka Connect."
                    }

                    if (setWallLevel || needSetReplicaLevelTask) {
                        // Ask to user if want to continue
                        def reader = getConsoleReader()
                        def continueSetup = askYesNo(reader, "\nDo you want to the setup script apply the required configuration changes automatically? (Y/n): ", true)
                        if (!continueSetup) {
                            throw new GradleException(
                                    "Database configuration is not suitable for Kafka Connect. Please apply the required changes manually and re-run this task:\n" +
                                            "1. Set wal_level to 'logical':\n" +
                                            "   ALTER SYSTEM SET wal_level = 'logical';\n" +
                                            "2. Set REPLICA IDENTITY FULL on public.etask_task table:\n" +
                                            "   ALTER TABLE public.etask_task REPLICA IDENTITY FULL;\n" +
                                            "After applying the changes, please restart the database server if necessary and re-run this task to ensure all settings are correct."
                            )
                        }

                        if (setWallLevel) {
                            try (def configSt = connection.prepareStatement("ALTER SYSTEM SET wal_level = 'logical'")) {
                                configSt.execute()
                            }
                        }
                        if (needSetReplicaLevelTask) {
                            try (def configSt2 = connection.prepareStatement("ALTER TABLE public.etask_task REPLICA IDENTITY FULL")) {
                                configSt2.execute()
                            }
                        }

                        if (setWallLevel || needSetReplicaLevelTask) {
                            println "‚ö†Ô∏è Database requirded configuration changes applied. A database restart may be required for changes to take effect."
                            if (setWallLevel) {
                                println "‚Üí wal_level set to 'logical'."
                            }
                            if (needSetReplicaLevelTask) {
                                println "‚Üí public.etask_task set to REPLICA IDENTITY FULL."
                            }
                            println "Please restart the database server if necessary and re-run this task to ensure all settings are correct."
                        }
                    }
                }
            } else {
                project.logger.debug('Skipping database connectivity test because DatabaseConnection class is not on the classpath.')
            }

        } catch (Exception e) {
            throw new GradleException("‚ùå Database connection test failed: ${e.message}\nPlease check your database connection settings (bbdd.systemUser, bbdd.systemPassword, bbdd.sid, bbdd.port) and ensure the database is reachable.")
        }

        // Check for variable kafka.enable. If not set, set it to true, but if already set in false, ask
        def kafkaEnabledSetted = project.hasProperty('kafka.enable')
        if (!kafkaEnabledSetted) {
            def reader = getConsoleReader()
            def kafkaEnabled = askYesNo(reader, "\nDo you want to enable Kafka Connect for database change data capture? (Y/n): ", true)
            saveInteractiveProp('kafka.enable', kafkaEnabled.toString())
            if (!kafkaEnabled) {
                println "Kafka Connect setup skipped as per user choice."
                return
            }
        } else if (project.getProperty('kafka.enable').toString().toBoolean() == false) {
            println "Kafka Connect setup will be skipped as 'kafka.enable' is set to false."
            //ask if the user wants to set it to true
            def reader = getConsoleReader()
            def kafkaEnabled = askYesNo(reader, "\nDo you want to enable Kafka Connect for database change data capture? (Y/n): ", true)
            saveInteractiveProp('kafka.enable', kafkaEnabled.toString())
            if (!kafkaEnabled) {
                println "Kafka Connect setup skipped as per user choice."
                return
            }

        }

        // Ask if the user wants to use etendorx_async docker container
        def dockerizedAsyncEnabled = project.hasProperty('docker_com.etendoerp.etendorx_async') && project.getProperty('docker_com.etendoerp.etendorx_async').toBoolean()
        if (!dockerizedAsyncEnabled) {
            def reader = getConsoleReader()
            dockerizedAsyncEnabled = askYesNo(reader, "\nDo you want to use Kafka connect as a Etendo Docker service? (Y/n): ", true)
            saveInteractiveProp('docker_com.etendoerp.etendorx_async', dockerizedAsyncEnabled.toString())
        }
        if (dockerizedAsyncEnabled && !project.hasProperty('docker_com.etendoerp.etendorx_utils')) {
            //Ask if want to enable the utilities, like Kafka UI and Jaeger
            def dockerizedUtilsEnabled = project.hasProperty('docker_com.etendoerp.etendorx_utils') && project.getProperty('docker_com.etendoerp.etendorx_utils').toBoolean()
            if (!dockerizedUtilsEnabled) {
                def reader = getConsoleReader()
                dockerizedUtilsEnabled = askYesNo(reader, "\nDo you want to use Kafka connect utilities (Kafka UI, Jaeger) as a Etendo Docker service? (Y/n): ", true)
            }
        }

        def kafkaConnectHost = getKafkaConnectHost(project, dockerizedAsyncEnabled)
        saveInteractiveProp('kafka.connect.host', kafkaConnectHost)

        def tableIncludeList = getKafkaConnectTables(project)
        saveInteractiveProp('kafka.connect.tables', tableIncludeList)
        def dockerizedDBEnabled = project.hasProperty('docker_com.etendoerp.docker_db') && project.getProperty('docker_com.etendoerp.docker_db').toBoolean()

        def dbHost = getkafkaConnectDBHost(project, dockerizedDBEnabled)
        saveInteractiveProp('kafka.connect.bbdd.host', dbHost)

        flushInteractiveSetup(project)


        println "üì° Checking Kafka Connect for connector '$connectorName'..."

        def configBody = """
        {
            "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
            "topic.prefix": "${connectorName}",
            "database.user": "${dbUser}",
            "database.dbname": "${dbName}",
            "database.hostname": "${dbHost}",
            "database.password": "${dbPass}",
            "database.port": "${dbPort}",
            "name": "${connectorName}",
            "table.include.list": "${tableIncludeList}",
            "plugin.name": "pgoutput",
            "key.converter": "org.apache.kafka.connect.json.JsonConverter",
            "key.converter.schemas.enable": "false",
            "value.converter": "org.apache.kafka.connect.json.JsonConverter",
            "value.converter.schemas.enable": "false",
            "snapshot.mode": "no_data"
        }
        """.stripIndent().replaceAll('\n', '').replaceAll(' +', ' ')

        def postBody = """
        {
            "name": "${connectorName}",
            "config": ${configBody}
        }
        """

        def checkProcess = ['curl', '-s', '-o', '/dev/null', '-w', '%{http_code}', "http://${kafkaConnectHost}:8083/connectors/${connectorName}"].execute()
        def statusCode = checkProcess.text.trim()

        def method = statusCode == "200" ? "PUT" : "POST"
        def url = statusCode == "200" ?
                "http://${kafkaConnectHost}:8083/connectors/${connectorName}/config" :
                "http://${kafkaConnectHost}:8083/connectors"

        def bodyToSend = (method == "PUT") ? configBody : postBody

        println "‚Üí Connector $connectorName ${statusCode == '200' ? 'exists' : 'does not exist'}, doing $method"

        def command = [
                'curl', '--silent', '--show-error', '--fail',
                '--request', method,
                '--url', url,
                '--header', 'Content-Type: application/json',
                '--data', bodyToSend
        ]

        def process = command.execute()
        def output = new StringWriter()
        def error = new StringWriter()
        process.consumeProcessOutput(output, error)
        def exitCode = process.waitFor()

        if (exitCode != 0) {
            throw new GradleException("‚ùå Error configuring Kafka Connect.\nCommand executed:\n${command.join(' ')}\nExit code: ${exitCode}\nSTDOUT:\n${output}\nSTDERR:\n${error}\n")
        } else {
            println "‚úÖ Kafka Connect $method completed.\n"
            // Attempt to flush collected interactive setup properties (if InteractiveSetupManager available)
            try {
                flushInteractiveSetup(project)
            } catch (Exception e) {
                project.logger.warn("Failed to flush interactive setup properties: ${e.message}")
            }
        }
    }
}

// Helper to obtain Kafka Connect host, with interactive fallback
private String getKafkaConnectHost(Project proj, boolean dockerizedAsyncEnabled) {
    if (proj.hasProperty('kafka.connect.host')) {
        return proj.getProperty('kafka.connect.host')
    }

    if (dockerizedAsyncEnabled) {
        return 'localhost'
    }

    def reader = getConsoleReader()
    def yellow = "\u001B[33;1m"
    def reset = "\u001B[0m"

    try {
        def isLocal = askYesNo(reader, "\n${yellow}Is Kafka Connect running on this machine and reachable at 'localhost'? (y/N): ${reset}", false)
        if (isLocal) {
            saveInteractiveProp('kafka.connect.host', 'localhost')
            return 'localhost'
        }

        def userHost = askInput(reader, "\n${yellow}Please enter the Kafka Connect host reachable from this machine (example: 192.168.1.2 or connect.example.com): ${reset}")
        if (userHost) {
            saveInteractiveProp('kafka.connect.host', userHost)
            return userHost
        }
    } catch (Exception e) {
        proj.logger.warn("Failed to read user input for Kafka Connect host: ${e.message}")
    }

    throw new GradleException("You must specify the 'kafka.connect.host' property or provide a valid host when prompted.")
}

// Helper to include required 'public.etask_task' table if missing
private String includeEtaskIfMissing(String tablesStr, Project proj, BufferedReader reader) {
    def yellow = "\u001B[33;1m"
    def reset = "\u001B[0m"

    def parts = []
    if (tablesStr) {
        parts = tablesStr.split(',').collect { it?.trim() }.findAll { it }
    }

    if (!parts.contains('public.etask_task')) {
        def include = askYesNo(reader, "\n${yellow}The 'public.etask_task' table is required for the async task processing to work.\n${yellow}Do you want to include it automatically in the tables list? (Y/n): ${reset}", true)
        if (include) {
            parts << 'public.etask_task'
        }
    }

    return parts.join(',')
}

// Helper to obtain kafka.connect.tables, with interactive prompt if missing
private String getKafkaConnectTables(Project proj) {
    def reader = getConsoleReader()
    try {
        if (proj.hasProperty('kafka.connect.tables')) {
            def tablesStr = getTypedProp('kafka.connect.tables')?.toString()?.trim()
            def result = includeEtaskIfMissing(tablesStr, proj, reader)
            if (result && result.trim()) {
                saveInteractiveProp('kafka.connect.tables', result)
                return result
            }
        } else {
            def yellow = "\u001B[33;1m"
            def reset = "\u001B[0m"
            def prompt = "\n${yellow}Please enter the comma-separated list of tables for Kafka Connect (example: public.table1,public.table2): ${reset}"
            def tablesStr = askInput(reader, prompt)
            def result = includeEtaskIfMissing(tablesStr, proj, reader)
            if (result && result.trim()) {
                saveInteractiveProp('kafka.connect.tables', result)
                return result
            }
        }
    } catch (Exception e) {
        proj.logger.warn("Failed to read user input for kafka.connect.tables: ${e.message}")
    }

    throw new GradleException("You must specify the 'kafka.connect.tables' property.")
}


private String getkafkaConnectDBHost(Project proj, boolean dockerizedDBEnabled) {
    if (proj.hasProperty('kafka.connect.bbdd.host')) {
        def val = getTypedProp('kafka.connect.bbdd.host')?.toString()
        saveInteractiveProp('kafka.connect.bbdd.host', val)
        return val
    }

    if (dockerizedDBEnabled) {
        saveInteractiveProp('kafka.connect.bbdd.host', 'db')
        return 'db'
    }

    def reader = getConsoleReader()
    def yellow = "\u001B[33;1m"
    def reset = "\u001B[0m"

    try {
        def isLocalDb = askYesNo(reader, "\n${yellow}Is the database running on this machine and reachable from the Kafka Connect container? (y/N): ${reset}", false)
        if (isLocalDb) {
            saveInteractiveProp('kafka.connect.bbdd.host', 'host.docker.internal')
            return 'host.docker.internal'
        }

        def userHost = askInput(reader, "\n${yellow}Please enter the database host reachable from the Kafka Connect container (example: 192.168.1.2 or db.example.com): ${reset}")
        if (userHost) {
            saveInteractiveProp('kafka.connect.bbdd.host', userHost)
            return userHost
        }
    } catch (Exception e) {
        project.logger.warn("Failed to read user input for DB host: ${e.message}")
    }

    throw new GradleException("You must specify the 'kafka.connect.bbdd.host' property or provide a valid DB host when prompted.")
}

task "jaeger.build" {
    description = 'Executing Jaeger and Opentelemetry Configurations'
    group = 'Docker'

    doLast {
        def yellow = "\u001B[33;1m"
        def reset = "\u001B[0m"
        def defaultOtlpEndpoint = "http://jaeger:4318"
        if (isRXDockerized() && isJaegerDockerized()) {
            // Copy Jaeger config.yml to volumes/jaeger
            project.logger.debug("‚öôÔ∏è Executing Jaeger Configuration Loader")
            project.copy {
                from sourceDir.map { it.toPath().resolve('jaeger').resolve('config.yaml').toFile() }
                into volumesDir.map { it.toPath().resolve('jaeger').toFile() }
                eachFile { jaegerConfigFile ->
                    project.logger.debug(">> üìÑ Copying Jaeger config file to jaeger volumen : ${jaegerConfigFile.file.path}")
                }
            }
            // Copy the Opentelemetry Java Agent jar file into ${VOLUMES_PATH}/otel
            project.logger.debug("‚öôÔ∏è Executing Opentelemetry Java Agent Configuration Loader")
            project.copy {
                from sourceDir.map { it.toPath().resolve('otel').resolve('opentelemetry-javaagent.jar').toFile() }
                into volumesDir.map { it.toPath().resolve('otel').toFile() }
                eachFile { opentelemetryJarFile ->
                    project.logger.debug(">> ü´ô Copying Opentelemetry Java Agent to otel volumen : ${opentelemetryJarFile.file.path}")
                }
            }
            // Copy the Opentelemetry Java Agent jar file into ${VOLUMES_PATH}/tomcat/webapps
            if (isTomcatDockerized() && isEnableOpentelemetryTomcat()) {
                project.logger.debug("‚öôÔ∏è Executing Opentelemetry in Tomcat Configuration Loader")
                project.copy {
                    from sourceDir.map { it.toPath().resolve('otel').resolve('opentelemetry-javaagent.jar').toFile() }
                    into volumesDir.map { it.toPath().resolve('tomcat').resolve('webapps').resolve('otel').toFile() }
                    eachFile { opentelemetryJarFile ->
                        project.logger.debug(">> ü´ô Copying Opentelemetry Java Agent to tomcat/webapps volumen : ${opentelemetryJarFile.file.path}")
                    }
                }
                def otel_tomcat_name = getTypedProp("otel.tomcat.name") ?: "tomcat"
                upsertEnvProperty('OTEL_TOMCAT_NAME', otel_tomcat_name)
                def otel_tomcat_otlp_endpoint = getTypedProp("otel.tomcat.otlp.endpoint") ?: defaultOtlpEndpoint
                upsertEnvProperty('OTEL_TOMCAT_OTLP_ENDPOINT', otel_tomcat_otlp_endpoint)
                def otel_tomcat_metrics_exporter = getTypedProp("otel.tomcat.metrics.exporter") ?: "none"
                upsertEnvProperty('OTEL_TOMCAT_METRICS_EXPORTER', otel_tomcat_metrics_exporter)
                def otel_tomcat_logs_exporter = getTypedProp("otel.tomcat.logs.exporter") ?: "none"
                upsertEnvProperty('OTEL_TOMCAT_LOGS_EXPORTER', otel_tomcat_logs_exporter)
                def otel_tomcat_traces_exporter = getTypedProp("otel.tomcat.traces.exporter") ?: "otlp"
                upsertEnvProperty('OTEL_TOMCAT_TRACES_EXPORTER', otel_tomcat_traces_exporter)
                def otel_tomcat_otlp_protocol = getTypedProp("otel.tomcat.otlp.protocol") ?: "http/protobuf"
                upsertEnvProperty('OTEL_TOMCAT_OTLP_PROTOCOL', otel_tomcat_otlp_protocol)
                def otel_tomcat_otlp_timeout = getTypedProp("otel.tomcat.otlp.timeout") ?: "10000"
                upsertEnvProperty('OTEL_TOMCAT_OTLP_TIMEOUT', otel_tomcat_otlp_timeout)
                project.logger.debug("üìÑ Setting TOMCAT_CATALINA_OPTS in .env file.")
                def otelFlags = [
                        "-javaagent:/usr/local/tomcat/webapps/otel/opentelemetry-javaagent.jar",
                        "-Dotel.resource.attributes=service.name=${otel_tomcat_name}",
                        "-Dotel.metrics.exporter=${otel_tomcat_metrics_exporter}",
                        "-Dotel.logs.exporter=${otel_tomcat_logs_exporter}",
                        "-Dotel.traces.exporter=${otel_tomcat_traces_exporter}",
                        "-Dotel.exporter.otlp.endpoint=${otel_tomcat_otlp_endpoint}",
                        "-Dotel.exporter.otlp.protocol=${otel_tomcat_otlp_protocol}",
                        "-Dotel.exporter.otlp.timeout=${otel_tomcat_otlp_timeout}"
                ].join(" \\\n    ")
                String tomcat_catalina_opts = "\"${otelFlags}\""
                upsertEnvProperty('TOMCAT_CATALINA_OPTS', tomcat_catalina_opts)
            } else {
                upsertEnvProperty('OTEL_TOMCAT_ENABLE', false)
                def env = envFile().envFile
                List<String> lines = env.readLines('UTF-8')
                project.logger.debug("${yellow} \n‚ùå Removing TOMCAT_CATALINA_OPTS of .env file.${reset}")
                lines = lines.findAll { !it.trim().startsWith('TOMCAT_CATALINA_OPTS=') }
            }
        } else if (isRXDockerized()) {
            upsertEnvProperty('OTEL_CONFIG_ENABLE', false)
            upsertEnvProperty('OTEL_DAS_ENABLE', false)
            upsertEnvProperty('OTEL_AUTH_ENABLE', false)
            upsertEnvProperty('OTEL_EDGE_ENABLE', false)
            upsertEnvProperty('OTEL_OBCONNSRV_ENABLE', false)
            upsertEnvProperty('OTEL_WORKER_ENABLE', false)
            upsertEnvProperty('OTEL_ASYNCPROCESS_ENABLE', false)
            if (isTomcatDockerized() && isEnableOpentelemetryTomcat()) {
                upsertEnvProperty('OTEL_TOMCAT_ENABLE', false)
                def env = envFile().envFile
                List<String> lines = env.readLines('UTF-8')
                project.logger.debug("${yellow} \n‚ùå Removing TOMCAT_CATALINA_OPTS of .env file.${reset}")
                lines = lines.findAll { !it.trim().startsWith('TOMCAT_CATALINA_OPTS=') }
            }
        }
    }
}

afterEvaluate {
    if (isRXDockerized() && tasks.hasProperty("generateEnvFile")) {
        tasks.named("generateEnvFile").configure { task ->
            task.finalizedBy("rx.env.file")
        }
        tasks.named("resources.build").configure { task ->
            task.dependsOn("rx.setup.files")
        }
        tasks.named("resources.up").configure { task ->
            task.dependsOn("rx.setup.files")
            task.finalizedBy("rx.setup")
        }
        tasks.named("update.database").configure { task ->
            task.dependsOn("rx.das.stop")
        }
        tasks.named("smartbuild").configure { task ->
            task.finalizedBy("rx.das.restart")
        }
        if (isJaegerDockerized()) {
            tasks.named("smartbuild").configure { task ->
                task.dependsOn("jaeger.build")
            }
            tasks.named("resources.up").configure { task ->
                task.dependsOn("jaeger.build")
            }
        }
    }
    if (isRXDockerized() && tasks.named("install")) {
        tasks.named("install").configure { task ->
            task.finalizedBy("resources.build")
        }
    }
}
