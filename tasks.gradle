def ETENDORX_PRODUCTION_REPOSITORY_URL = "https://maven.pkg.github.com/etendosoftware/com.etendoerp.platform.extensions"
def ETENDORX_SNAPSHOT_REPOSITORY_URL = "https://repo.futit.cloud/repository/etendo-snapshot-jars"
project.ext {
    ETENDORX_VERSION = "2.3.3"
}

def volumesDir = project.providers
    .provider {
        def volumenPath = project.findProperty('VOLUMES_PATH')
        if (volumenPath) {
            return file(volumenPath)
        } else {
            return project.layout.buildDirectory.dir("../volumes").get().getAsFile()
        }
    }

def sourceDir = project.providers
    .provider {
        def red = "\u001B[31;1m"
        def reset = "\u001B[0m"

        Project moduleProject = project.findProject(":modules")
        Project rxProject = null
        if (moduleProject != null) {
            rxProject = moduleProject.findProject("com.etendoerp.etendorx")
        }
        File jarModulesLocation = new File(project.buildDir, "etendo"+File.separator+"modules")
        File rxJarModule = new File(jarModulesLocation, "com.etendoerp.etendorx")
        if (rxProject != null || rxJarModule.exists()) {
            return rxProject != null ? rxProject.projectDir.path : rxJarModule.path
        } else {
            throw new GradleException("${red}❌ RX module not found.${reset}")
        }
    }
    .map { file(it) }

def isRXDockerized() {
    getTypedProp('docker_com.etendoerp.etendorx') ?: false
}

def isJaegerDockerized() {
    getTypedProp('docker_com.etendoerp.etendorx_utils') ?: false
}

def isTomcatDockerized() {
    getTypedProp('docker_com.etendoerp.tomcat') ?: false
}

def isEnableOpentelemetryTomcat() {
    getTypedProp('otel.tomcat.enable') ?: false
}

def isConnectorDockerized() {
    getTypedProp('docker_com.etendoerp.etendorx_connector') ?: false
}

def isAsyncProcessDockerized() {
    getTypedProp('docker_com.etendoerp.etendorx_async') ?: false
}

task "rx.setup" {
    description = 'Finds all Docker Compose YAML files and copies them to build/compose'
    group = 'Docker'

    doLast {
        if (isRXDockerized()) {
            println("Copying RX config files")
            // Ensure the destination directory exists
            def destDir = layout.buildDirectory.dir("rxconfig").get().asFile
            if (!destDir.exists()) {
                destDir.mkdirs()
            }

            def dirs = ['modules', layout.buildDirectory.dir("etendo/modules").get().asFile]
            dirs.each { dir ->
                // Collect .yaml and .yaml.template files
                def yamlFiles = fileTree(dir: dir, include: '**/rxconfig/*.yaml').collect { it.name }
                def templateFiles = fileTree(dir: dir, include: '**/rxconfig/*.yaml.template')

                templateFiles.each { template ->
                    def yamlName = template.name.replace('.template', '')
                    def destFile = new File(destDir, yamlName)

                    // If the .yaml file doesn't exist, use the template to generate it
                    if (!yamlFiles.contains(yamlName)) {
                        println("Using template for missing file: ${yamlName}")
                        copy {
                            from template
                            into destDir
                            rename { it.replace('.template', '') }
                        }
                    } else {
                        // If the .yaml file exists, copy it directly
                        println("Using existing .yaml file: ${yamlName}")
                        copy {
                            from new File(template.parent, yamlName)
                            into destDir
                        }
                    }
                    def content = destFile.text
                    content = content.replace('{TOMCAT_URL}', isTomcatEnabled ? 'tomcat' : 'host.docker.internal')
                    content = content.replace('{TOMCAT_PORT}', isTomcatEnabled ? '8080' : tomcatPort.toString())
                    content = content.replace('{BBDD_URL}', isBBDDEnabled ? 'db' : 'host.docker.internal')
                    content = content.replace('{BBDD_PORT}', isBBDDEnabled ? '5432' : project.property("bbdd.port").toString())
                    content = content.replace('{BBDD_SID}', project.property("bbdd.sid").toString())
                    content = content.replace('{CONTEXT_NAME}', project.property("context.name").toString())
                    content = content.replace('{ETENDORX_BASEPACKAGE}', project.hasProperty("etendorx.basepackage") ? project.property("etendorx.basepackage").toString() : "")
                    content = content.replace('{OBCON_URL}', isTomcatEnabled ? 'obconnsrv' : 'host.docker.internal')
                    destFile.text = content
                }
            }
            executeDockerComposeCommand("cp ${destDir} config:/")
        }
    }
}

task "rx.env.file" {
    description = 'Generates the .env file for RX'
    group = 'Docker'

    doLast {
        def props = envFile()
        def env = props.envFile
        def properties = props.properties
        def version = "${project.ext.ETENDORX_VERSION}"

        upsertEnvProperty('ETENDORX_VERSION', version)
        def etendorx_repository_url = "${ETENDORX_PRODUCTION_REPOSITORY_URL}"
        def etendorx_repository_user = "${properties.getProperty("githubUser")}"
        def etendorx_repository_password = "${properties.getProperty("githubToken")}"
        if ("${ETENDORX_VERSION}".contains("SNAPSHOT")) {
            etendorx_repository_url = "${ETENDORX_SNAPSHOT_REPOSITORY_URL}"
            etendorx_repository_user = "${properties.getProperty("nexusUser")}"
            etendorx_repository_password = "${properties.getProperty("nexusPassword")}"
        }
        upsertEnvProperty('ETENDORX_REPOSITORY_URL', etendorx_repository_url)
        upsertEnvProperty('ETENDORX_REPOSITORY_USER', etendorx_repository_user)
        upsertEnvProperty('ETENDORX_REPOSITORY_PASSWORD', etendorx_repository_password)

        def destUrl = isBBDDEnabled ? "db" : "host.docker.internal"
        def port = isBBDDEnabled ? "5432" : getTypedProp("bbdd.port")
        def sid = getTypedProp("bbdd.sid") ?: "etendo"
        def contextName = getTypedProp("context.name") ?: "etendo"
        upsertEnvProperty("ETENDORX_DB_HOST", destUrl)
        upsertEnvProperty("ETENDORX_DB_PORT", port)
        upsertEnvProperty("ETENDORX_DB_SID", sid)

        def tomcatHost = "tomcat"
        if (!isTomcatEnabled) {
            tomcatHost = "host.docker.internal"
        }
        def configServerUrl = "http://${tomcatHost}:${tomcatPort}/${contextName}/buildConfig"
        upsertEnvProperty("ETENDORX_CONFIG_SERVER_URL", configServerUrl)
    }
}

task "rx.das.restart" {
    dependsOn "rx.setup"
    doLast {
        if (isRXDockerized()) {
            executeDockerComposeCommand("restart das")
        }
    }
}

task "rx.das.stop" {
    doLast {
        if (isRXDockerized()) {
            executeDockerComposeCommand("stop das")
        }
    }
}

task "kafkaConnectSetup" {

    doLast {
        def connectorName = "default"
        def dbUser = getTypedProp('bbdd.systemUser') ?: 'postgres'
        def dbName = getTypedProp('bbdd.sid') ?: 'etendo'
        def dbPass = getTypedProp('bbdd.systemPassword') ?: 'syspass'
        def dbPort = isBBDDEnabled ? '5432' : project.property("bbdd.port").toString()

        if (!project.hasProperty('kafka.connect.tables')) {
            throw new GradleException("You must specify the 'kafka.connect.tables' property.")
        }
        def tableIncludeList = getTypedProp('kafka.connect.tables')
        def dbHost
        if (project.hasProperty('kafka.connect.bbdd.host')) {
            dbHost = getTypedProp('kafka.connect.bbdd.host')
        } else if (project.hasProperty('docker_com.etendoerp.docker_db') && project.getProperty('docker_com.etendoerp.docker_db').toBoolean()) {
            dbHost = "db"
        } else {
            throw new GradleException("You must specify the 'kafka.connect.bbdd.host' property.")
        }

        println "📡 Checking Kafka Connect for connector '$connectorName'..."

        def configBody = """
        {
            "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
            "topic.prefix": "${connectorName}",
            "database.user": "${dbUser}",
            "database.dbname": "${dbName}",
            "database.hostname": "${dbHost}",
            "database.password": "${dbPass}",
            "database.port": "${dbPort}",
            "name": "${connectorName}",
            "table.include.list": "${tableIncludeList}",
            "plugin.name": "pgoutput",
            "key.converter": "org.apache.kafka.connect.json.JsonConverter",
            "key.converter.schemas.enable": "false",
            "value.converter": "org.apache.kafka.connect.json.JsonConverter",
            "value.converter.schemas.enable": "false",
            "snapshot.mode": "no_data"
        }
        """.stripIndent().replaceAll('\n', '').replaceAll(' +', ' ')

        def postBody = """
        {
            "name": "${connectorName}",
            "config": ${configBody}
        }
        """
        def kafkaConnectHost
        if (project.hasProperty('kafka.connect.host')) {
            kafkaConnectHost = project.getProperty('kafka.connect.host')
        } else if (project.hasProperty('docker_com.etendoerp.etendorx_async') && project.getProperty('docker_com.etendoerp.etendorx_async').toBoolean()) {
            kafkaConnectHost = "localhost"
        } else {
            throw new GradleException("You must specify the 'kafka.connect.host' property.")
        }

        def checkProcess = ['curl', '-s', '-o', '/dev/null', '-w', '%{http_code}', "http://${kafkaConnectHost}:8083/connectors/${connectorName}"].execute()
        def statusCode = checkProcess.text.trim()

        def method = statusCode == "200" ? "PUT" : "POST"
        def url = statusCode == "200" ?
                "http://${kafkaConnectHost}:8083/connectors/${connectorName}/config" :
                "http://${kafkaConnectHost}:8083/connectors"

        def bodyToSend = (method == "PUT") ? configBody : postBody

        println "→ Connector $connectorName ${statusCode == '200' ? 'exists' : 'does not exist'}, doing $method"

        def command = [
                'curl', '--silent', '--show-error', '--fail',
                '--request', method,
                '--url', url,
                '--header', 'Content-Type: application/json',
                '--data', bodyToSend
        ]

        def process = command.execute()
        def output = new StringWriter()
        def error = new StringWriter()
        process.consumeProcessOutput(output, error)
        def exitCode = process.waitFor()

        if (exitCode != 0) {
            throw new GradleException("❌ Error configuring Kafka Connect.\nCommand executed:\n${command.join(' ')}\nExit code: ${exitCode}\nSTDOUT:\n${output}\nSTDERR:\n${error}\n")
        } else {
            println "✅ Kafka Connect $method completed.\n"
        }
    }
}

task "jaeger.build" {
    description = 'Executing Jaeger and Opentelemetry Configurations'
    group = 'Docker'

    doLast {
        def yellow = "\u001B[33;1m"
        def reset = "\u001B[0m"
        def defaultOtlpEndpoint = "http://jaeger:4318"
        if (isRXDockerized() && isJaegerDockerized()) {
            // Copy Jaeger config.yml to volumes/jaeger
            project.logger.debug("⚙️ Executing Jaeger Configuration Loader")
            project.copy {
                from sourceDir.map { it.toPath().resolve('jaeger').resolve('config.yaml').toFile() }
                into volumesDir.map { it.toPath().resolve('jaeger').toFile() }
                eachFile { jaegerConfigFile ->
                    project.logger.debug(">> 📄 Copying Jaeger config file to jaeger volumen : ${jaegerConfigFile.file.path}")
                }
            }
            // Copy the Opentelemetry Java Agent jar file into ${VOLUMES_PATH}/otel
            project.logger.debug("⚙️ Executing Opentelemetry Java Agent Configuration Loader")
            project.copy {
                from sourceDir.map { it.toPath().resolve('otel').resolve('opentelemetry-javaagent.jar').toFile() }
                into volumesDir.map { it.toPath().resolve('otel').toFile() }
                eachFile { opentelemetryJarFile ->
                    project.logger.debug(">> 🫙 Copying Opentelemetry Java Agent to otel volumen : ${opentelemetryJarFile.file.path}")
                }
            }
            // Copy the Opentelemetry Java Agent jar file into ${VOLUMES_PATH}/tomcat/webapps
            if (isTomcatDockerized() && isEnableOpentelemetryTomcat()) {
                project.logger.debug("⚙️ Executing Opentelemetry in Tomcat Configuration Loader")
                project.copy {
                    from sourceDir.map { it.toPath().resolve('otel').resolve('opentelemetry-javaagent.jar').toFile() }
                    into volumesDir.map { it.toPath().resolve('tomcat').resolve('webapps').resolve('otel').toFile() }
                    eachFile { opentelemetryJarFile ->
                        project.logger.debug(">> 🫙 Copying Opentelemetry Java Agent to tomcat/webapps volumen : ${opentelemetryJarFile.file.path}")
                    }
                }
                def otel_tomcat_name = getTypedProp("otel.tomcat.name") ?: "tomcat"
                upsertEnvProperty('OTEL_TOMCAT_NAME', otel_tomcat_name)
                def otel_tomcat_otlp_endpoint = getTypedProp("otel.tomcat.otlp.endpoint") ?: defaultOtlpEndpoint
                upsertEnvProperty('OTEL_TOMCAT_OTLP_ENDPOINT', otel_tomcat_otlp_endpoint)
                def otel_tomcat_metrics_exporter = getTypedProp("otel.tomcat.metrics.exporter") ?: "none"
                upsertEnvProperty('OTEL_TOMCAT_METRICS_EXPORTER', otel_tomcat_metrics_exporter)
                def otel_tomcat_logs_exporter = getTypedProp("otel.tomcat.logs.exporter") ?: "none"
                upsertEnvProperty('OTEL_TOMCAT_LOGS_EXPORTER', otel_tomcat_logs_exporter)
                def otel_tomcat_traces_exporter = getTypedProp("otel.tomcat.traces.exporter") ?: "otlp"
                upsertEnvProperty('OTEL_TOMCAT_TRACES_EXPORTER', otel_tomcat_traces_exporter)
                def otel_tomcat_otlp_protocol = getTypedProp("otel.tomcat.otlp.protocol") ?: "http/protobuf"
                upsertEnvProperty('OTEL_TOMCAT_OTLP_PROTOCOL', otel_tomcat_otlp_protocol)
                def otel_tomcat_otlp_timeout = getTypedProp("otel.tomcat.otlp.timeout") ?: "10000"
                upsertEnvProperty('OTEL_TOMCAT_OTLP_TIMEOUT', otel_tomcat_otlp_timeout)
                project.logger.debug("📄 Setting TOMCAT_CATALINA_OPTS in .env file.")
                def otelFlags = [
                        "-javaagent:/usr/local/tomcat/webapps/otel/opentelemetry-javaagent.jar",
                        "-Dotel.resource.attributes=service.name=${otel_tomcat_name}",
                        "-Dotel.metrics.exporter=${otel_tomcat_metrics_exporter}",
                        "-Dotel.logs.exporter=${otel_tomcat_logs_exporter}",
                        "-Dotel.traces.exporter=${otel_tomcat_traces_exporter}",
                        "-Dotel.exporter.otlp.endpoint=${otel_tomcat_otlp_endpoint}",
                        "-Dotel.exporter.otlp.protocol=${otel_tomcat_otlp_protocol}",
                        "-Dotel.exporter.otlp.timeout=${otel_tomcat_otlp_timeout}"
                ].join(" \\\n    ")
                String tomcat_catalina_opts = "\"${otelFlags}\""
                upsertEnvProperty('TOMCAT_CATALINA_OPTS', tomcat_catalina_opts)
            } else {
                upsertEnvProperty('OTEL_TOMCAT_ENABLE', false)
                def env = envFile().envFile
                List<String> lines = env.readLines('UTF-8')
                project.logger.debug("${yellow} \n❌ Removing TOMCAT_CATALINA_OPTS of .env file.${reset}")
                lines = lines.findAll { !it.trim().startsWith('TOMCAT_CATALINA_OPTS=') }
            }
        } else if (isRXDockerized()) {
            upsertEnvProperty('OTEL_CONFIG_ENABLE', false)
            upsertEnvProperty('OTEL_DAS_ENABLE', false)
            upsertEnvProperty('OTEL_AUTH_ENABLE', false)
            upsertEnvProperty('OTEL_EDGE_ENABLE', false)
            upsertEnvProperty('OTEL_OBCONNSRV_ENABLE', false)
            upsertEnvProperty('OTEL_WORKER_ENABLE', false)
            upsertEnvProperty('OTEL_ASYNCPROCESS_ENABLE', false)
            if (isTomcatDockerized() && isEnableOpentelemetryTomcat()) {
                upsertEnvProperty('OTEL_TOMCAT_ENABLE', false)
                def env = envFile().envFile
                List<String> lines = env.readLines('UTF-8')
                project.logger.debug("${yellow} \n❌ Removing TOMCAT_CATALINA_OPTS of .env file.${reset}")
                lines = lines.findAll { !it.trim().startsWith('TOMCAT_CATALINA_OPTS=') }
            }
        }
    }
}

task "jaeger.restart" {
    dependsOn "jaeger.build"
    doLast {
        if (isRXDockerized() && isJaegerDockerized()) {
            project.logger.lifecycle("🔍 Restarting Jaeger using Docker")
            executeDockerComposeCommand("restart jaeger")
        }
    }
}

afterEvaluate {
    if (isRXDockerized() && tasks.hasProperty("generateEnvFile")) {
        tasks.named("generateEnvFile").configure { task ->
            task.finalizedBy("rx.env.file")
        }
        tasks.named("resources.up").configure { task ->
            task.finalizedBy("rx.setup")
        }
        tasks.named("update.database").configure { task ->
            task.dependsOn("rx.das.stop")
        }
        tasks.named("smartbuild").configure { task ->
            task.finalizedBy("rx.das.restart")
        }
    }
    if (isRXDockerized() && isJaegerDockerized()) {
        tasks.named("smartbuild").configure { task ->
            task.finalizedBy("jaeger.restart")
        }
        tasks.named("resources.up").configure { task ->
            task.dependsOn("jaeger.build")
        }
    }
}
